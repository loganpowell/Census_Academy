<!-- ---
title: 'Getting Started with `cljs.core.async`'
created: '6-01-2018'
canonicalUrl: 'https://github.com/loganpowell/cljs-guides/blob/master/src/core-async/core-async-intro.md'
tags: ['cljs', 'core-async', 'clojurescript', 'go', 'chan']
license: 'public-domain'
--- -->

## Interogatives and Analogies

Feature | Mac/Fnc | Analogy
--- | :---: | ---
`go` | mac |
`go-loop` | mac |
`alt!` | mac |
`alts!` | fnc | 
`chan` | fnc | the plate (buffered = on a conveyor) with the order (handlers)
`>!` | fnc | ordering sushi at the conveyor restaurant
`<!` | fnc | getting sushi at the conveyor restaurant
`put!` | fnc | ordering sushi for delivery
`take!` | fnc | getting sushi delivered
`buffer` | fnc | the length of the conveyor belt
`sliding-buffer` | 
`dropping-buffer` | 



- Why?
	- decouple processes from each other (modularity of functionality)
	- use transducers (single set of collection manipulation operations across async and sync collections)
- What?
	- Macros:
		- go
		- go-loop
		- alt!
	- Functions
		- chan
		- "parking"/blocking (implements back-pressure) operations
			- >!
			- <!
		- non-blocking (geared for integration with functionality outside of go blocks)
			- take!
			- put!
- How?
- When?
- Where?





















# Getting Started with `cljs.core.async`

This guide was meant to help those just getting started with `core.async`, but why would we want to learn something new for asynchronous communicating between our functions/systems when we already have a way to do that (i.e., callbacks)?

---
![Comparing Channels to Direct Communication](http://endot.org/notes/2014-02-14-core-async-clojure/compare.png)

#### *There comes a time in all good programs when components or subsystems must stop communicating directly to each other.*

### *Conveyance must become first class*.
-- [Rich Hickey: `core.async` début](https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/CoreAsync.md)

---

`core.asyc` outperforms other async vehicles in a number of ways, but here are just a few:

- **Processes are first class**: you can use `core.async` channels and `go` blocks not only to pass data/values around, but pass also processes themselves! This feature enables you to take processes and de/compose them to do incredibly sophisticated things in just a few lines of code.
- **Write asynchronous code as if it was synchronous** (using `go` blocks)
- They're [faster]((http://swannodette.github.io/2013/08/23/make-no-promises) than Promises.
- **Treat channel i/o data as you would _any other_ collection in ClojureScript**. Enabling you to learn one set of operations (e.g., `map`, `filter`, etc... using [transducers](https://blog.venanti.us/using-transducers-with-core-async-clojurescript/)) to rule them all!

This last selling point was really the clincher for me. The idea of learning one set of operations that could be used across all my code, both asynchronous and synchronous, in a way that would improve my skills with the *language* (not just the library) seems more efficient IMHO.

## Introduction

This is the first of a [series of guides](./core-async-index.md), which cover - in an incremental fashion - the wonderful, but nuanced world of "simple made easy" asynchronous communication in your ClojureScript programs via `core.async`.

Most of the code included in [the examples](./core.cljs) were stolen from [David Nolen](https://github.com/swannodette/swannodette.github.com/blob/master/code/blog/src/blog/csp/core.cljs), which he goes over in his introductory [meetup video](https://www.youtube.com/watch?v=AhxcGGeh5ho).

### Differences in `core.async` between Clojure and ClojureScript

There are a few differences between the features of `core.async` in Clojure and ClojureScript as a matter of necessity. Though Clojure has threads, Node/JavaScript only has a single thread, so any thread-blocking operation will not - by default - be available in ClojureScript's implementation. However, there are ways you can get more features by using extensions to the library such as [`superv.async`](https://github.com/replikativ/superv.async), but those are out of the scope of this guide.

Very roughly speaking - anything that has "blocking" semantics in `clojure.core.async` (e.g., anything with two `!!`s) will not be  available in `cljs.core.async`.

## Macros Covered Herein:
- [`go`](https://clojuredocs.org/clojure.core.async/go): Provides an first-class process (and lexical "block") where internal asynchronous functions can be written in a synchronous fashion.

## Functions Covered:

Function | Short Description | Syntax | Must be used in a `go` block?
--- | --- | :---: | :---:
[`chan`](https://clojuredocs.org/clojure.core.async/chan) | Channel: async coordination vehicle | async | true
[`>!`](https://clojuredocs.org/clojure.core.async/>!) | "Parking" put -> Put to `chan` | sync | true
[`<!`](https://clojuredocs.org/clojure.core.async/>!) | "Parking" take -> Take from a `chan` | sync | true

## Dependencies

You'll need to add this to the namespace of your file:

```clj
(ns core-async.core
  (:require  [cljs.core.async :refer [>! <! chan]]
             [cljs.core.async :refer-macros [go]])
  (:use [clojure.repl :only (source)]))
```
The `source` function is a handy sister to the natively available `doc` function, which allows you to inspect the definition of a given macro or function in a library.

Also, you'll need to add the [current version](https://github.com/clojure/core.async#releases-and-dependency-information) of `core.async` to your project's `:dependencies`:

```clj
[org.clojure/core.async <current version>]
```


---
# `go` Block Basics

#### [Usage](https://clojuredocs.org/clojure.core.async/go):
###### `(go & body)`

#### Elaboration:

- Asynchronously executes the `body`, returning immediately to the calling thread.
- Any visible calls to `<!`, `>!` and `alt!`/`alts!` channel operations within the body will **block (if necessary) by 'parking'** the calling thread rather than tying up the only JS thread when in ClojureScript.
- Upon completion of the operation, the `body` will be resumed.
- Returns a channel which will receive the result of the `body` when completed
---

`go` blocks provide an environment where we can escape callback hell. I like to think of them as pulling us into a new little programming world where we can write our async code in it's logical order. As [Stuart Halloway](https://twitter.com/stuarthalloway?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor) explains in his [great talk](https://www.infoq.com/presentations/core-async) about `core.async` (paraphrasing):

`go` is a first class process abstraction (can be passed as a value to other processes) that will either use real threads (if available) or use "magic-callback-hell-behind-the-scenes-threads" giving users who don't have real threads to work with (i.e., ClojureScript/JavaScript users) the ability to write code as if they did. `go` uses a state-machine with "parking" to enable this.

We will touch on what "parking" means [in another post](./puts-takes-alts.md). For now, let's jump right in!

```clj
(.log js/console (go 5))
```
In our console we will see that **the result of the `go` block is a `ManyToManyChannel`** with the following semantics:

```clj
{ takes: { head: 0, tail: 0, length: 0, arr: [ <32 empty items> ] },
  dirty_takes: 0,
  puts: { head: 0, tail: 0, length: 0, arr: [ <32 empty items> ] },
  dirty_puts: 0,
  buf:
   { buf: { head: 0, tail: 0, length: 0, arr: [Array] },
     n: 1,
     'cljs$lang$protocol_mask$partition0$': 2,
     'cljs$lang$protocol_mask$partition1$': 0 },
  closed: false,
  add_BANG_:
   { [Function: G__25820]
     'cljs$core$IFn$_invoke$arity$1': [Function: G__25820__1],
     'cljs$core$IFn$_invoke$arity$2': [Function: G__25820__2] } }
```
But the value (`5`) that we might have hoped we could get out is hidden inside the channel as we can see in a following log to our console:

```
nil
```

So, what if we tried to value out with `<!`? Let's try eval'ing this:
```clj
(.log js/console (<! (go 5)))
```

...aaaand we get this:
```
... throw (new Error("<! used not in (go ...) block")) ...
```

Since we're trying to "take" (`<!`) the value from *outside* the `go` block, we get an error. It may seem a bit odd at first, but the quickest way to remedy this is to wrap our `<!` (taking operation) in a `go` block:

```clj
(go (.log js/console (<! (go 5))))
```
And now we get our value out:
```
5
```

### Takeaway:
**You can only do a "parking" operation (e.g., `<!` / `>!`) from a channel *within* a `go` block**.

In the case above, we created our channel in an unconventional way (by using a `go` instead of a channel directly), just to show that what is returned from a `go` is a channel (`chan`).

---

# `chan` Basics

> Check out this fun overview of channels from Eric Normand [on YouTube](https://www.youtube.com/watch?v=msv8Fvtd6YQ)

#### [Usage](https://clojuredocs.org/clojure.core.async/chan):
###### `(chan)`
###### `(chan buf-or-n)`
###### `(chan buf-or-n xform)`
###### `(chan buf-or-n xform ex-handler)`

#### Elaboration:
- Creates a channel with an optional buffer, an optional transducer (like `(map f)`, `(filter p)` etc or a composition thereof), and an optional exception-handler.  
- If `buf-or-n` is a number, will create and use a fixed buffer of that size. If a *transducer* is supplied a buffer must be specified.
- `ex-handler` must be a `fn` of one argument - if an exception occurs during transformation it will be called with the Throwable as an argument, and any non-nil return value will be placed in the channel.
---

If `go` blocks create an environment where we can write async code as if it were sync code, how do we communicate or pass information between these environments? Are we limited to doing this stuff only inside the `go` blocks? The answer is "no".

**The way we pass work done inside one `go` block to another `go` block is with channels (`chan`).**

Let's introduce a *bona fide* channel into our code. To start, let's treat the `chan` as a simple internal means of conveying something:

```clj
(let [c (chan)]
  (go
    (.log js/console "We got here")
    (.log js/console (<! c)) ; take from the channel
    (.log js/console "We made progress")))
```
Logging out:

```
We got here
```

Ok... what just happened? Why didn't we get the second console log? Well, this is the first lesson we need to learn about channels. We tried to take (`<!`) from an empty `chan`. What happened? We closed the `go` block before we put anything on that could be taken (`(go ...)<-closing paren closes the go block`) and thus abandoned the thread we provisioned.

**Until a put is offset by a take (or vice versa) within the channel the operation will be suspended (will "wait") until it's satisfied by its counterpart or garbage collected.**

Let's expand on the example by communicating between two `go` blocks living in the scope:


```clj
(let [c (chan)]
  (go
    (.log js/console "We got here")
    (.log js/console (<! c))
    (.log js/console "We made progress"))
  (go
    (>! c 5)))
```

This time we should get something like this logged to our console:

```
We got here
5
We made progress
```

The second console log was made possible by the following `go` blocks putting operation `>!`, which "woke up" the first by putting a value into the shared channel.  This is the beginnings of inter `go` block communication. The potential of which is *systemic*.

One more example to drive it home:

```clj
(let [c (chan)]
  (go
    (.log js/console "Before")
    (>! c (js/Date.)) ; put the current date into the channel
    (.log js/console "After"))
  (go
    (.log js/console "Order")
    (.log js/console (<! c)) ; take the date out
    (.log js/console "doesn't matter")))
```

Which logs:
```
Before
Order
2018-05-28T21:36:32.725Z
doesn't matter
After
```

What's happening here? The first `go` block's second console log isn't allowed to read until it's put operation `>!` is satisfied by the take operation in the second `go` block.

This is the primary takeaway from this example:

**Writes (`>!`/`put!`) and reads (`<!`/`take!`) need to be balanced in order to facilitate the sequential flow of information within and/or between `go` blocks.**

"Parking" is a feature, which prevents our provisioned processes from running out of control forever after. We can determine how we handle too many puts to a channel that has not pending takes with the various `buffer` functions, which we'll cover in a [later guide](./core-async-index.md).


## Channels In Summary:

If you're passing a `chan` within or between `go` blocks in the same or different scopes, any unbalanced put to or take from that `chan` will be "suspended". In this case, it's accidentally forewarning of our code to use the combination of `let`...`go` ;)

---
<!-- ## Up Next

If this wetted your appetite to learn a bit more about `core.async`, check out [the next lesson](./core-async.md) -->

## Additional Resources

- If you haven't already, take a gander at the clojure.core.async ([API Reference](https://clojure.github.io/core.async/) or [docs](https://clojuredocs.org/clojure.core.async)), do so!
- Check out this [blog post](https://medium.com/@hlship/some-observations-about-clojure-core-async-dc0ad44b8e2f) from [Howard M. Lewis](https://twitter.com/hlship) (the core contributor of a fantastic [Clojure GraphQL Server](https://github.com/walmartlabs/lacinia/graphs/contributors)) covering what to think about when spinning up threads.

### Examples of `core.async`

Check out Some Advanced Examples of `core.async`in Action in Actual Projects

1) [NetRunner: Game](https://github.com/mtgred/netrunner/search?q=core.async&unscoped_q=core.async)
2) [Goya: Pixel Editor](https://github.com/jackschaedler/goya/search?q=core.async&unscoped_q=core.async)
3) [Wordsmith Markdown Editor](https://github.com/yuhama/wordsmith/blob/848976002c8a0830e7ee85a352530f610d112389/src/wordsmith/core.cljs)

### For the theorist reader:

Read more about the concepts behind `core.async`: [Communicating Sequential Processes: CSP](https://en.wikipedia.org/wiki/Communicating_sequential_processes)).

<!-- ---
title: '`cljs.core.async` `alts!`, `timeout` and "Parking"'
created: '5-31-2018'
canonicalUrl: 'https://github.com/loganpowell/cljs-guides/blob/master/src/core-async/core-async.md'
tags: ['cljs', 'core-async', 'clojurescript', 'go', 'clojure']
license: 'public-domain'
--- -->


# `cljs.core.async` `alts!`, `timeout` and "Parking"

In this follow up to [the introduction of `core.async` basics](./core-async-intro.md) we'll get a bit deeper into the rabbit hole and do some more interesting things to expose the inner workings of `core.async`. This is also, a part of [a series](./core-async-guides.md) on the subject.

## Macros Covered:
- [`go-loop`](https://clojuredocs.org/clojure.core.async/go-loop): Syntactic sugar for `(go (loop [] ...))`

### Functions Covered:

Function | Short Description | Syntax | Must be used in a `go` block?
--- | --- | :---: | :---:
[`alts!`](https://clojuredocs.org/clojure.core.async/alts!) | `chan` flow control | sync | true
[`timeout`](https://clojuredocs.org/clojure.core.async/timeout)| Return a channel that closes after set milliseconds | async | false

## Dependencies

You'll need to add this to the namespace of your file:

```clj
(ns core-async.core
  (:require  [cljs.core.async :refer [>! <! chan timeout alts!]]
             [cljs.core.async :refer-macros [go go-loop]]))
```

# Anatomy of a Channel

Building upon our newfound [basic grasp of *what a `chan` does*](./core-async-intro.md) (the "queue", which can serve as a vehicle for conveying information between processes in `core.async`), let's explore *how it does it*. Trust me, understanding this will save you lots of frustration and misunderstanding.

Since channels "spin up" (virtual) threads, any ongoing putting or taking operations to/from the `chan` can remain waiting ("parked") in the thread provisioned for the `chan` until garbage collected. We'll go in more depth into what this means in this guide.

Let's look again at the diagram from [the introductory guide](./core-async-intro.md)

![Comparing Channels to Direct Communication](http://endot.org/notes/2014-02-14-core-async-clojure/compare.png)

... and *zoom in* on one of those little yellow boxes (**"Channel"**) included in Rich Hickey's [presentation](https://vimeo.com/100518968) and its relationship between other parts of your program (SPI = service provider interface):

![SPI](https://raw.githubusercontent.com/matthiasn/talk-transcripts/master/Hickey_Rich/ImplementationDetails/00.05.37.jpg)

We'll continue to use a "conveyor belt" analogy in this guide. Accordingly, you can think of the `impl/put! [val handler]` as operation(s) that seek to convey values to another part of our program. `impl/take! [handler]` are the operations on the other side that want those values. In between them is a conveyor (channel) capable of moving those values along asynchronously without either side needing to know about the other.

Let's start our exploration with a slightly manipulated [example](http://swannodette.github.io/2013/07/12/communicating-sequential-processes) provided by David Nolen.

> Before you eval this example, know it might require a restart of your remote repl (depending on your environment) to terminate the looping `go` block. So, you can just trust that this would never end if you don't want that headache.

```clj
(def ch (chan))

(go (while true (<! (timeout 250)) (>! ch 1)))
(go (while true (<! (timeout 500)) (>! ch 2)))
(go (while true (<! (timeout 750)) (>! ch 3)))

(go-loop []
  (recur (.log js/console (str "process: " (<! ch)))))
```
Which logs the following processes. Note the breaks between each log here represent single occurrences of `(recur...)`, which will be of interest to us in a moment:

- `process: 2`
- `process: 3`
- `process: 2`
- `process: 1`
- `process: 2`
- `process: 1`
- `process: 1`
- `process: 1`
`... happily ever after`

Here, we've set three processes (`(go (while...))`) in motion, trying to put values onto the conveyor (`ch`) and a separate process (`(go-loop ...)`) trying to take values off. These processes know nothing of each other. They communicate with each other via the channel.

While this is an impressive display of the power of `core.async` (Try running three concurrent processes in JavaScript in three lines of code? Ha!), it is also a call for you to be careful when setting your operations to/from a channel in motion.

# Control Flow with `timeout` and `alts!`

Stopping a looping `(go...)` block is tricky business. The `(go...)` blocks are operations outside of the channel. The channel is not a part of them, nor they a part of it. So, what if we don't want a never ending process from our `chan`? One way of dealing with this is to use the `core.async` [`alts!`](https://clojuredocs.org/clojure.core.async/alts!) as a control mechanism.

![The omniconveyor](https://cdn-images-1.medium.com/max/900/1*vdhvl1KtmHTztQrTFauRGQ.gif)

> Alt* is actually the tricky operation. **Almost everything that's built into (`core.async`s) channel implementation is there to support `alt*`** because alt is the hard part. - Rich Hickey

---
# `alts!` Basics

#### [Usage](https://clojuredocs.org/clojure.core.async/alts!):
###### `(alts! ports & {:as opts})`

#### Elaboration:
- Completes at most one of several channel operations.
- Must be called inside a `(go ...)` block.
- `ports` is a vector of channel endpoints, which can be either a channel to take from or a vector of `[channel-to-put-to val-to-put]`, in any combination.
- Takes will be made as if by `<!`, and puts will be made as if by `>!`. Unless the `:priority` option is `true`, if more than one port operation is ready a non-deterministic choice will be made.
- If no operation is ready and a `:default` value is supplied, `[default-val :default]` will be returned, otherwise `alts!` will park until the first operation to become ready completes.
- Returns `[val port]` of the completed operation, where `val` is the value taken for takes, and a boolean (`true` unless already closed, as per `put!`) for puts.

##### `opts` are passed as `:key val ...` Supported options:

- `:default val` - the value to use if none of the operations are immediately ready
- `:priority true` - (default `nil`) when `true`, the operations will be tried in order.

Note: there is no guarantee that the `port` or `val` expressions will be used, nor in what order should they be, so you should *not* depend on them for side effects.

---


Let's see this in action:

```clj
(defn timeout-chan [port]
  (let [tmt (timeout 3000)]
    (go (while true (<! (timeout 250)) (>! port 1)))
    (go (while true (<! (timeout 500)) (>! port 2)))
    (go (while true (<! (timeout 750)) (>! port 3)))
    (go-loop [_ []] ; accumulator = placeholder, replaced with each `(recur (.log...`
      (let [[val ch] (alts! [port tmt])]
        (cond
          (= ch tmt) (.log js/console (str "done"))
          :else
          (recur (.log js/console (str "process: " (<! port)))))))))

(def test-chan (chan))
```

Then eval this:
```clj
(timeout-chan test-chan)
```

Which logs:
- `process: 2`
- `process: 3`
- `process: 2`
- `process: 1`
- `process: 2`
- `process: 1`
- `process: 1`
- `process: 1`
- `process: 1`
- `process: 3 done`

`alts!` returns one of the "ports" (channels) passed to it as args, acting like a valve, making switching between threads possible.

Essentially, `alts!` is a control structure, which will take from one of a number of channels depending on which is available at the time of choosing. In this case, the timeout block won't be available to take from until 3000 milliseconds have elapsed, at which point it will remain available for taking from the looping `(recur ... (<! port))` take, whereas the values coming from the triplet sequence of putting `(go (while...))` loops are only available periodically. Thus, the `tmt` channel gets taken from when its time runs out, effectively starving the taking operations in the looping `(go (while...))` blocks, thus "parking" their puts.


# "Parking"

Let's zoom in further into our channel, temporarily disregarding the i/o relationships to focus on the inner workings of the `core.async` channel (our conveyor belt) alone:

![conveyor](https://github.com/matthiasn/talk-transcripts/raw/master/Hickey_Rich/ImplementationDetails/00.06.23.jpg)

Right now, we'll gloss over the `buffer` and focus on what's happening on the edges of the channel. For now, think of a buffer-less channel like a ridiculously short conveyor belt that can't hold anything. In this case, the channel acts only as a coordination point where two completely decoupled operations can interact with each other asynchronously. I.e., *the putting **handler** (operation) will have to wait for a taking **handler** (or vice-versa) on the other side to do the hand-off, whereupon the **value** is conveyed between them.*

As we'll see [in another guide](./core-async-index.md), adding a buffer effectively stretches the conveyor belt out giving it capacity to coordinate conveyance between value-producing *operations* **and** hold conveyed *values* along the way.

In the previous code example, the three `(go (while...))` blocks pushing values into a channel can be thought of as "little programs", which spin up their own little (JavaScript virtual) threads that can park put operations until takes are able to facilitate asynchronous data flow. As such, those little programs will continue to push values into the shared `chan` (`test-chan`) until its buffer (if provided) is full. In this case, since we didn't provide a buffer, the `test-chan` will park pending put operations until more take operations enable those putting operations' values to be conveyed.

Let's illustrate what this means for our `test-chan` by eval'ing the same function call on it again:

```clj
(timeout-chan test-chan)
```

Now, note the additional processes that get logged out - and in what fashion - here:

- `process: 1`
- `process: 2 process: 1`
- `process: 3 process: 1`
- `process: 2 process: 1`
- `process: 1`
- `process: 3 process: 2 process: 1`
- `process: 1`
- `process: 2 process: 1`
- `process: 3 process: 1`
- `process: 2 process: 1`
- `process: 1`
- `process: 3 done`

Let's compare these two previous logs side-by-side:

First Log | Second Log
--- | ---
 ` ` | `process: 1`
`process: 2` | `process: 2 process: 1`
`process: 3` | `process: 3 process: 1`
`process: 2` | `process: 2 process: 1`
`process: 1` | `process: 1`
`process: 2` | `process: 3 process: 2 process: 1`
`process: 1` | `process: 1`
`process: 1` | `process: 2 process: 1`
`process: 1` | `process: 3 process: 1`
`process: 1` | `process: 2 process: 1`
` ` | `process: 1`
`process: 3 done` | `process: 3 done`

You can see the difference between the two logs above (the exact log output is not critical here) as a manifestation of what's going on inside the `test-chan`. When we switched the `go-loop` to the `timeout` channel (with `alts!`) in our first eval, we left the values being pushed by the previous `(go...)` blocks in a *waiting* state, i.e., **parked**. Upon second eval, the `test-chan` gets an extra dose of puts because it consumes - simultaneously:

- the second eval's `(go...)` put values
- the first evals - post `alts!` - *un-parked* put values.
- the first eval's `(go...)` put values - enabled by new `(recur ... (<! port))` taking operations

I hope this is starting to make sense. When I first encountered this, I was confused, so I hoped to help others who might wonder what's going on here by elaborating.

---
# `timeout` Basics

#### [Usage](https://clojuredocs.org/clojure.core.async/timeout):
###### `(timeout msecs)`

#### Elaboration:
- Returns a channel that will close after `msecs`
---

We used `timeout` above to terminate our process. It's important to note that - as per the [documentation](https://clojuredocs.org/clojure.core.async/timeout) - while `timeout` does return a channel, that the channel is only there to signal you when the given number of milliseconds has elapsed and it signals that by giving you a closed `chan`. This is one method for properly terminating a long-running process: Stop it taking from or putting to the target `chan` by switching to a closed channel (e.g., via the `alts!` function).


# Next Up!

We'll build some more responsibility into our channels using buffers. Find the link to the guide and more [in the index](./core-async-index.md).

# Getting Help

## Join the Clojurian's Slack Channel

In the making of this guide, I leveraged the wonderful community of Clojure(Script) users on the [Clojurians' Slack](http://clojurians.net/).

- If you're new to Clojure(Script), I highly recommend the [#beginners channel](https://clojurians.slack.com/messages/beginners/)
- If you're new to `core.async`, there's a [#core-async channel](https://clojurians.slack.com/messages/core-async/) as well!

I think you'll find the members of the community are some of the most generous people you'll ever meet.

## Special Thanks

- Great help from these guys on the Clojurians' Slack:
  - [noisesmith](https://twitter.com/noisesmith)
  - [hiredman](https://github.com/hiredman)
  - [SeanCorfield](https://twitter.com/seancorfield)
  - [BrianRubinton](https://twitter.com/brianru)
- [David Nolen](https://twitter.com/swannodette) for his awesome [blog posts](http://swannodette.github.io/2013/07/12/communicating-sequential-processes) and [webinars](https://purelyfunctional.tv/programmer-profiles/david-nolen/) and - of course - for [ClojureScript!](https://github.com/clojure/clojurescript/graphs/contributors)
- [Timothy Baldridge](https://twitter.com/timbaldridge) and [Alex Miller](https://twitter.com/puredanger) for [`core.async`](https://github.com/clojure/core.async/graphs/contributors). Tim also has some great [`core.async` tutorials](https://tbaldridge.pivotshare.com/home)!

## Additional Resources

- Implementation of `core.async` [Rich Hickey presentation](https://vimeo.com/100518968)
  - [transcript and slides](https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/ImplementationDetails.md) courtesy of [Matthias Nehlsen](https://github.com/matthiasn)
- Presentation: [`core.async` debut](https://www.youtube.com/watch?v=VrmfuuHW_6w) with Rich Hickey
  - [Transcript and slides](https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/CoreAsync.md) courtesy of [Matthias Nehlsen](https://github.com/matthiasn)
- `core.async`: Concurrency Without Callbacks from [Stuart Halloway](https://www.infoq.com/presentations/core-async)
  - github [source for examples](https://github.com/cognitect/async-webinar) from the talk
- Timeouts and Working with Multiple Channels via Parking and `alts!` by [Will Fleming](https://wtfleming.github.io/2015/05/27/adventures-with-core-async-part-two-parking-timeouts-alt/)
- Other Examples from [Tim Baldridge](https://github.com/halgari/clojure-conj-2013-core.async-examples/blob/master/src/clojure_conj_talk/core.clj)
- David Nolen [Webinar Examples](https://github.com/cognitect/async-webinar/blob/master/src/webinar/core.cljs)
- Interview with Tim Baldridge [discussing `core.async`](https://www.infoq.com/interviews/baldridge-core-async).

#### More on Threads and Parking:

There's a great [blog post on braveclojure](https://www.braveclojure.com/core-async/) on the parking mechanics of `core.async` (and processes in general) which I'd recommend for those that need to learn more. There was also a very concise [Hacker News comment](https://news.ycombinator.com/item?id=5961407), which I found enlightening:

> The IoC (Inversion of Control) threads work by converting park-able functions into Single-Static Assignment (SSA) form and then compiled to a state machine. Essentially, each time a function is "parked", it returns a value indicating where to resume from. These little state machine functions are basically big switch statements that you don't need to write by hand. This design is inspired by C#'s async compilation strategy.
<!-- ---
title: '`cljs.core.async` Buffers, `put!` and `take!`'
created: '5-31-2018'
canonicalUrl: 'https://github.com/loganpowell/cljs-guides/blob/master/src/core-async/core-async.md'
tags: ['cljs', 'core-async', 'clojurescript', 'go', 'clojure']
license: 'public-domain'
--- -->

# `cljs.core.async` Buffers, `put!` and `take!`

### Functions Covered:

Function | Short Description | Syntax | Must be used in a `go` block?
--- | --- | :---: | :---:
[`buffer`](https://clojuredocs.org/clojure.core.async/buffer) | A fixed capacity of a `chan`, which parks over-capacity puts  | async | false
[`put!`](https://clojuredocs.org/clojure.core.async/put!) | "Put bang" -> Put to `chan` | async | false
[`take!`](https://clojuredocs.org/clojure.core.async/take!)| "Take bang" -> Take from a `chan` | async | false
[`sliding-buffer`](https://clojuredocs.org/clojure.core.async/sliding-buffer) | A buffer, which allows newest over capacity puts by dropping oldest puts in the buffer (doesn't park overcapacity puts)| async | false
[`dropping-buffer`](https://clojuredocs.org/clojure.core.async/dropping-buffer) | A buffer, which "drops" newest puts when full (doesn't park overcapacity puts) | async | false

## Dependencies

You'll need to add this to the namespace of your file:

```clj
(ns core-async.core
  (:require  [cljs.core.async :refer [>! <! chan timeout put! take! alts! buffer sliding-buffer dropping-buffer]]
             [cljs.core.async :refer-macros [go go-loop]]))
```


Let's rehash our [memory](./alts-timeout-parking.md) of the inner workings of the `core.async` channel.

![conveyor](https://github.com/matthiasn/talk-transcripts/raw/master/Hickey_Rich/ImplementationDetails/00.06.23.jpg)

Up [until now](./core-async-index.md) we've been using buffer-less channels. These have served as handy coordination points where two completely decoupled operations can interact with each other asynchronously, but there's still a bit to be desired from this mechanism. I.e., *the putting **handler** (operation) has had to wait for a taking **handler** (or vice-versa) on the other side to do the hand-off, whereupon the **value** is conveyed between them.*

By adding a buffer, we effectively stretch the "conveyor belt" out giving it capacity to coordinate conveyance between value-producing *operations* **and** hold conveyed *values* along the way.

# `put!` and `take!`

So far, we've only been using the "parking" syntax (`<!` & `>!`) for taking from and putting to a `chan`, which must take place in a `go` block. Let's discuss their `go` block-dismembered siblings, [`put!`](https://clojuredocs.org/clojure.core.async/put!) and [`take!`](https://clojuredocs.org/clojure.core.async/take!).

---

# `put!` Basics

#### [Usage](https://clojuredocs.org/clojure.core.async/put!):
###### `(put! port val)`
       `(put! port val fn1)`
       `(put! port val fn1 on-caller?)`

#### Elaboration:
- Asynchronously puts a `val` into `port`, calling `fn1` (if supplied) when complete, passing `false` if `port` is already closed.
- `nil` values are not allowed.
- If `on-caller?` (default `true`) is `true`, and the put is immediately accepted, will call `fn1` on calling thread.  
- Returns true unless `port` is already closed.

# `take!` Basics

#### [Usage](https://clojuredocs.org/clojure.core.async/take!):
###### `(take! port fn1)`
       `(take! port fn1 on-caller?)`

#### Elaboration:
- Asynchronously takes a `val` from `port`, passing to `fn1`. Will pass `nil` if closed.
- If `on-caller?` (default `true`) is `true`, and value is immediately available, will call `fn1` on calling thread.
- Returns `nil`.

---

Usually, when I'm getting acquainted with the features and language of a library, I find this sort of explanation a bit self-referential and prefer layman's terms. Here's a great [one from StackOverflow](https://stackoverflow.com/a/35342456):

> If `put!` is not matched by a take immediately, it places a pending put operation (the value to be put on the channel + the `put!` callback) on a queue internal to the channel...
> The `put!`/`take!` callback will be called **if**:
> 1) the put/take is not immediately matched **or**
> 2) an explicit `false` is passed in as a final argument to the `put!`/`take!` call (this argument is called `on-caller?`).

There's also a great summary of when to use `put!` and `take` (instead of `>!` and `<!`) from [a lispcast blog post](https://lispcast.com/willy-wonka-core-async/)

> USE `put!` and `take!` TO GET STUFF into and out of YOUR CHANNELS FROM OUTSIDE.
`put!` and `take!` (**do not park as do `>!` and `<!`**) are ways to get values from outside of `core.async` into `core.async` without blocking. For instance, if you’re using a callback-style, which is very common in JavaScript, you will want to make your callback call `put!` to get the value onto a channel.

This is corroborated and expanded upon by Rich Hickey [in his deep dive talk on `core.async`](https://vimeo.com/100518968)

> ...if you're getting raw data from some external source, (you should be using) `put!`, but **there's no backpressure on put `put!`**. All those `put!`s where do they go? ... What should happen if I can't keep up?
> ... One of the ways you can take care of not being able to keep up is to implement backpressure by using a blocking construct (i.e., `(go...)`) on the entry point. The other is just to use (a) "windowed buffer"

Let's see an example of how this will impact our code

```clj

(defn toggle-chan [process stopper]
  (go (while true (<! (timeout 250)) (>! process 1)))
  (go (while true (<! (timeout 500)) (>! process 2)))
  (go (while true (<! (timeout 750)) (>! process 3)))
  (go-loop [_ []] ; accumulator = placeholder, replaced with each `(recur (.log...`
    (let [[val ch] (alts! [process stopper])]
      (cond
        (= ch stopper) (take! stopper #(.log js/console (str "take val: " %)))
        :else
        (recur (.log js/console (str "process: " (<! process))))))))

(defn stopping-put-async [port val]
  (put! port val #(.log js/console (str "put val: " %))))

(defn stopping-put-park [port val]
  (go (>! port val #(.log js/console (str "put val: " %)))))

(def test-chan2 (chan))
(def stopping-chan (chan 2))

```


# Getting Started with Buffers

If you don't provide a buffer explicitly, `core.async` will create an unbuffered channel where a put operation will park until conveyed by a take operation.
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMTc5NDA5NDcsNjAwNTE0NjYsLTE5Mj
U2NzU2MDcsLTI1MDI0ODc5LDYyNTE1NDUzLC0xNjUyOTM1MDcx
XX0=
-->